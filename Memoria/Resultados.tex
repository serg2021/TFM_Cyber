\chapter{Resultados}
\label{ch:res}

En este capítulo pasaremos a explicar cada experimento realizado para cada modelo, las métricas que se usarán para medir los resultados y comentaremos qué modelo consigue mejores prestaciones en base a éstos.
%TODO_DONE: introduce lo que se va a hacer en este capítulo

\section{Métricas}

A continuación vamos a explicar en qué consisten las métricas en las que nos basaremos para cotejar los experimentos realizados.

\subsection{Error Rate}

Para saber con cuánta veracidad y exactitud se han clasificado las imágenes usaremos esta métrica denominada \textbf{``Error Rate''} (o \textbf{Tasa de errores}). Simplemente indica el número de imágenes bien clasificadas junto con el número de imágenes mal clasificadas; a continuación se calcula en base a estos datos qué porcentaje de errores han habido durante la clasificación.

Realmente es una métrica muy común usada en una gran cantidad de ramas científicas, de modo que no es de sorprender que la hayamos escogido para este proyecto.

%\begin{figure}[H]
%  \centering
%  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Iou_1.eps}
%    \caption{Imagen Original}
%  \end{subfigure}
%    \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/IoU_2.eps}
%    \caption{Predicción}
%  \end{subfigure}
%  \caption{Imágenes para visualizar el \ac{mIoU}}
%\end{figure}

\subsection{Average Precision Score}

Con esta métrica se pretende evaluar la precisión media de los resultados de las predicciones. Para ello, se realiza la llamada curva \ac{PR} (o curva de \textbf{Precisión-Sensibilidad}); con ella se puede ver si la clasificación de las imágenes se ha realizado correctamente, es decir, sin falsos positivos en la misma (\textbf{Precisión}), y si se han detectado bien las imágenes por el modelo dentro de todo el set de imágenes , es decir, si han habido falsos negativos durante el proceso y si dentro de los mismos (y de los positivos reales) se han detectado correctamente los positivos (\textbf{Sensibilidad}). %cita

Es un poco confuso de entender, pero simplemente indica la efectividad del sistema en términos de falsos positivos y falsos negativos. En la curva los dos ejes están muy relacionados entre sí: si se aumenta la precisión, disminuirá la sensibilidad (y al revés).

Sin embargo, esta  curva no es la métrica que aquí explicamos. La precisión media se calcula a partir de la misma y es, a grandes rasgos, una forma de representar todos los valores de la curva en uno solo.

Para decirlo de forma resumida, la \textbf{precisión media} toma la curva \ac{PR} y realiza la media ponderada de los valores de la ``Precisión'' adquiridas en cada umbral de decisión, es decir, en cada valor de decisión que define la precisión del sistema (si variamos el umbral, variará a su vez la precisión del sistema, y por lo tanto servirá para dictaminar si el modelo es preciso o no); como pesos para realizar la media ponderada se utilizará el incremento de la sensibilidad del umbral anterior al actual. A continuación mostramos la fórmula para comprender mejor, de forma visual, lo explicado en este punto: %cita

\begin{equation}\label{eq:apscore}
AP = \sum_{n}(R_n - R_{n-1})P_n
\end{equation}

donde $P_n$ es la \textbf{Precisión} y $R_n$ es la \textbf{Sensibilidad} en el umbral \textbf{n}. Cuanto más cercana a 1 esta métrica, mejor será el sistema.

Esta métrica realmente es muy buena para nuestros objetivos porque está pensada para usarse en un set de imágenes \textbf{no balanceado}, es decir, con más elementos del set con una etiqueta que con otra (recordemos que nuestro set se compone de 5000 imágenes, de las cuales 250 tienen un exploit en su interior).
%TODO_DONE: yo suelo añadir una sección explicando las métricas, pero no es necesario, si las explicas en cada experimento. Recuerda traer aquí la explicación de la mIOU para evaluar la segmentación semántica.
%TODO_DONE: organiza en secciones los distintos experimentos.

\subsection{Balanced Accuracy}

\textbf{Balanced Accuracy} es una métrica diseñada precisamente para problemas de clasificación con set de imágenes no balanceados, tanto para problemas de clasificación binarios (con dos etiquetas) como de multiclase (con más de dos etiquetas).

Esta métrica se define como la media de la \textbf{Sensibilidad} obtenida de cada clase (recordemos que la \textbf{Sensibilidad} sirve para medir cuántos positivos han sido detectados por el modelo correctamente). Se utiliza para evaluar el rendimiento de un modelo de clasificación. Cuanto más cercano a 1 su valor, mejor será el modelo. %cita

\subsection{ROC AUC Score}

Como ya vimos en el capítulo \ref{ch:sota}, la curva \ac{ROC} se crea a partir de los valores de la \ac{TPR} y la \ac{FPR} en distintos umbrales. Consecuentemente, la \ac{AUC} se puede calcular a partir de la \ac{ROC},y es el área bajo la curva formada por ésta. Cuanto mayor sea su valor, más completo y eficaz será el modelo, ya que así se ve cómo aumenta el valor de la \ac{TPR} y cómo decrece el valor de la \ac{FPR}.

Todo este proceso se realiza bajo el contexto de la predicción realizada por el modelo para clasificar las imágenes. Se puede usar tanto para clasificación binaria y multiclase. %cita

\section{Evaluación del sistema $ISA^{2}$}

A continuación vamos a desarrollar cómo se realizará esta evaluación de la velocidad según la base de datos de $ISA^{2}$. Explicaremos cómo se realiza tanto para Swiftnet como para DeepLab y, tras obtener los resultados, detallaremos por qué son de esa forma, es decir, qué ha influido en ellos para que sean así; finalmente, comentaremos qué sistema de regresión da mejores resultados de entre todos ellos. Para ello nos serviremos de la métrica \ac{MAE} anteriormente nombrada.

Cabe destacar que Swiftnet es un modelo \textbf{Real-Time} (\cite{swiftnet}), de modo que es un modelo más rápido que DeepLab, el cual, por el contrario, necesita de un tiempo de procesamiento demasiado elevado para realizar su función. En concreto Swiftnet trabaja a 39.9 \ac{FPS} para la resolución de Cityscapes (\textbf{1024 x 2048}) usando una tarjeta gráfica \textbf{NVIDIA GTX 1080 Ti} (la nuestra), mientras que DeepLab trabaja a 8 \ac{FPS} en una \textbf{NVIDIA Titan X} (\cite{deeplab}); esta última tiene características que, en comparación con la nuestra, hacen que sea una tarjeta gráfica con un rendimiento sensiblemente peor (\cite{gtx_titan}). Como resultado se puede ver que la diferencia del tiempo de procesado entre ambos modelos es notable, a pesar de trabajar sobre dos tarjetas gráficas con distintas características; ya que la diferencia entre ambas, aunque latente, no influye en gran medida para medir estos tiempos. %TODO_DONE: añade información de tiempos de procesado de uno y otro, en lo que se refiere a segmentación semántica.

\subsection{Diseño del experimento}

Para realizar la evaluación de la velocidad en $ISA^{2}$ vamos a trabajar de la siguiente forma. Los sistemas de regresión funcionan de manera que necesitan de cierta información para poder ser entrenados y, después, poder predecir (en base a ese entrenamiento) los resultados que se esperan de ellos. Parte de dicha información se compone de la base de datos de $ISA^{2}$, de la cual pasamos a explicar cómo está organizada y cómo se utilizará en esta parte del proyecto.

En el capítulo \ref{ch:isa2} explicábamos que la base de datos de $ISA^{2}$ estaba compuesta por dos carpetas (\textbf{Highway} y \textbf{Urban}) correspondientes a imágenes en autovías y entornos urbanos. Internamente, estaban organizadas por subcarpetas que contenían las imágenes que se usarían para realizar los experimentos (\textbf{H1} y \textbf{H2} para \textit{Highway}, y \textbf{U1}, \textbf{U2} y \textbf{U3} para \textit{Urban}). Para este experimento usaremos el mismo sistema de directorios con la diferencia de que, en esta ocasión, las imágenes habrán sido procesadas por el modelo Swiftnet, y no por DeepLab.

Los sistemas de regresión funcionan de manera que necesitan de cierta información para poder ser entrenados y, después, poder predecir (en base a ese entrenamiento) los resultados que se esperan de ellos.

Para entrenar los sistemas usaremos las funciones de MatLab que explicábamos en el capítulo anterior. Sin embargo, el parámetro \textbf{\textit{X}}, común a dichas funciones, no representará a un sólo descriptor de imagen, sino a todo un set de éstos correspondientes a las imágenes de una de las subcarpetas antes mencionadas. Lo mismo pasa con el parámetro \textbf{\textit{Y}}: Éste tendrá información de la velocidad adecuada para cada una de las imágenes de dicha subcarpeta; esta información la tenemos guardada en unos archivos \textbf{``.mat''}.

Dicho esto pasamos a señalar con qué subcarpetas entrenamos el modelo, o dicho de otra forma, qué contendrá el parámetro \textit{X}: Para el caso de las autovías lo haremos con la subcarpeta \textbf{H2}, y para los entornos urbanos usaremos las subcarpetas \textbf{U1} y \textbf{U2}, siguiendo las especificaciones marcadas en el artículo original (\cite{isa2}), para poder así comparar resultados.

Ya hemos hablado acerca de cómo se entrenan los sistemas de regresión y con qué secuencias de imágenes se hace. Ahora pasamos a explicar cómo se realiza la predicción.

Para que los sistemas puedan predecir estimaciones de la velocidad nos serviremos de una función de MatLab llamada:

\begin{center}
\textit{predict(Mdl,Z)}
\end{center}

Esta función (\cite{predict}) devuelve como respuesta la predicción del modelo de regresión \textit{Mdl} para los datos de prueba de la matriz \textit{Z}. Los datos de prueba de dicha matriz se corresponderán con una subcarpeta del anterior sistema de archivos. Para las autovías escogeremos la subcarpeta \textbf{H1}, mientras que para los entornos urbanos escogeremos \textbf{U3}.

Cabe destacar que esta función se utiliza en 3 de los 4 sistemas de regresión que hemos utilizado, puesto que en Lasso predecimos los resultados limitando el tamaño de los coeficientes de regresión (\cite{coef_lasso}).
%TODO_DONE hay que añadir una subsección donde se explique el diseño del experimento, es decir, qué se emplea para training, y qué para test, de cada una de las secuencias que forman ISA^2

En la siguiente tabla pasamos a mostrar los resultados tanto de la versión anterior de $ISA^{2}$ (\cite{isa2}) como de la desarrollada en este trabajo. Como ya dijimos anteriormente, el \ac{MAE} será la métrica que usaremos para esta tarea, pues indica cuánta precisión ha habido en términos de la estimación de la velocidad.

\begin{table}[H]
\centering
\resizebox{16cm}{!}{
\begin{tabular}{|l|l|l|l|l|l|}\cline{1-6}
& & \multicolumn{2}{|l|}{\textbf{MAE Swiftnet}} & \multicolumn{2}{|l|}{\textbf{MAE DeepLab}} \\ \cline{1-6}
\textbf{Regresión} & \textbf{Nivel de \ac{SPP}} & \textbf{Highway (\%)} & \textbf{Urban (\%)} & \textbf{Highway (\%)} & \textbf{Urban (\%)}\\ \cline{1-6}
\multirow{4}{*}{\textbf{\textit{Lineal}}} & 1 & 12.22 & 8.95 & 10.32 & 8.38 \\ \cline{2-6}
& 2 & 13.94 & 9.45 & 11.18 & 8.81 \\ \cline{2-6}
& 3 & 13.39 & \textbf{\textit{11.79}} & 15.5 & \textbf{\textit{10.83}}\\ \cline{2-6}
& 4 & \textbf{\textit{55.61}} & \textbf{\textit{12.19}} & \textbf{\textit{55.61}} & \textbf{\textit{12.19}} \\ \cline{1-6}
\multirow{4}{*}{\textbf{\textit{Lasso}}} & 1 & 12.90 & 9.23 & 11.29 & 8.43 \\ \cline{2-6}
 & 2 & 13.80 & 9.40 & 11.7 & 8.62 \\ \cline{2-6}
 & 3 & 13.47 & 10.16 & 10.8 & 9.25\\ \cline{2-6}
 & 4 & 13.7 & 9.63 & 13.7 & 9.42\\ \cline{1-6}
\multirow{4}{*}{\textbf{\textit{Boosting Trees}}} & 1 & 13.43 & \textbf{9.83} & 11.35 & \textbf{10.14} \\ \cline{2-6}
 & 2 & 14.97 & \textbf{10.52} & 12.23 & \textbf{10.72}\\ \cline{2-6}
 & 3 & 14.75 & \textbf{10.08} & 10.37 & \textbf{10.12}\\ \cline{2-6}
 & 4 & \textbf{14.16} & \textbf{10.02} & \textbf{14.22} & \textbf{10.02}\\ \cline{1-6}
\multirow{4}{*}{\textbf{\textit{SVR}}} & 1 & 11.13 & \textbf{8.65} & 9.69 & \textbf{9.55} \\ \cline{2-6}
 & 2 & 12.24 & \textbf{8.98} & 9.98 & \textbf{9.09}\\ \cline{2-6}
 & 3 & 12.09 & \textbf{9.60} & 9.78 & \textbf{9.62}\\ \cline{2-6} 
 & 4 & \textbf{12.01} & 9.53 & \textbf{12.08} & 9.52\\ \cline{1-6}
\end{tabular}
}
\caption{Tabla de resultados} %TODO_DONE: añade más información , sobre qué experimento, incluso comenta el ganador.
\label{tab:Resul_ISA2}
\end{table}

Los valores de Swiftnet que aparecen \textbf{resaltados} indican que son mejores que los valores de DeepLab (\textbf{también resaltados}) para esa fila.

Estos resultados se han generado siguiendo el proceso de entrenamiento y prueba anteriormente indicado en cada uno de los sistemas, es decir: utilizando las subcarpetas \textbf{H2}, \textbf{U1} y \textbf{U2} para entrenar los sistemas, siendo la primera la correspondiente a autovías y el resto a escenarios urbanos; y usando las subcarpetas \textbf{H1} (autovías) y \textbf{U3} (núcleos urbanos) como prueba.

Como se puede apreciar para este experimento, los mejores resultados son los que da el sistema \textbf{\textit{\ac{SVR}}} en todos los niveles de agrupación para entornos urbanos (con la excepción del nivel 4 que, en autovías, es sensiblemente mejor usando Swiftnet, y en entornos urbanos el \ac{MAE} de ambos modelos está casi a la par). El sistema \textbf{\textit{Boosting Trees}} tampoco se queda atrás y en todos sus niveles consigue lo mismo que el sistema \textit{\ac{SVR}}: Una mejora del \ac{MAE} de Swiftnet con respecto del de DeepLab en entornos urbanos y, en el último nivel, vuelve a tener dicha mejora en autovías. El resto de sistemas (\textbf{\textit{Lasso y Lineal}}) siguen siendo peores ejecutándose con los resultados de Swiftnet, y en concreto el sistema de regresión \textit{Lineal}, para el nivel de agrupación 4, es el que da unos resultados realmente catastróficos a pesar de haber sido corregidos como explicamos más adelante.%TODO_DONE: da más detalles, donde se entrena, dódne se prueba, se trata de repetir lo del diseño del experimento

Es en este punto en que el que se puede ver la influencia que tiene \ac{SPP} sobre los descriptores de imagen y, por lo tanto, sobre los resultados de la tabla.

Cuando generamos los descriptores de imagen estamos utilizando \ac{SPP} para que, según el nivel de agrupación que se use, se obtenga más o menos información en éstos. Recordemos que el nivel de agrupación indica el nivel de granularidad que tendrán los descriptores, y por lo tanto la cantidad de información que llevarán consigo.

Analizando la tabla \ref{tab:Resul_ISA2}, vemos cómo para mayores niveles de agrupación, la precisión de los sistemas de regresión va en aumento. Esto puede verse en los niveles 3 y 4 de todos los sistemas, exceptuando el \textit{Lineal} que de ahora en adelante excluiremos por la poca certeza de sus resultados en comparación con el resto. Entre estos niveles, la diferencia entre el \ac{MAE} de un modelo en un determinado escenario con el \ac{MAE} del mismo modelo en el mismo escenario (pero en un distinto nivel) es muy pequeña. Esto es porque cuando aumentamos al nivel 4, el grado de granularidad es superior y tendrá más precisión para estimar la velocidad en comparación con el anterior. Sin embargo, el nivel 3 también aporta una granularidad muy alta y, por ende, una estimación muy precisa; por lo tanto, si con el nivel 3 ya obtenemos resultados concisos, con el nivel 4 podemos refinarlos hasta obtener una estimación con mayor nivel de certeza.

Esto no siempre es así, porque puede pasar que en el nivel 4 se tomen en consideración datos que el nivel 3 había pasado por alto y como resultado nos dé un \ac{MAE} mayor en el último nivel. A lo que nos referimos con todo esto es a la posibilidad de que mientras los sistemas de regresión se ejecutan con datos de nivel 3, al no tener la misma profundidad que los de nivel 4, pueden obviar información relevante que con un nivel superior serían capaces de procesar. Esto se puede ver, por ejemplo, en la estimación del sistema \textit{Lasso} tanto para Swiftnet como para DeepLab. Sin embargo, este suceso no ocurre sólo en los niveles 3 y 4, para comprobarlo basta con revisar los niveles iniciales del sistema \textit{\ac{SVR}}.

Dicho todo esto, y comparando los valores de la tabla, podemos asegurar que los mejores sistemas con Swiftnet son \textbf{\textit{Boosting Trees}} y \textbf{\textit{\ac{SVR}}}. Para concretar más, vamos a puntualizar cómo el sistema \textit{\ac{SVR}} es mejor incluso, y es debido al reducido \ac{MAE} que tiene en todos sus niveles en comparación con el sistema \textit{Boosting Trees}.

En conclusión, podemos afirmar que el mejor sistema de regresión que se puede utilizar para el modelo Swiftnet es \textbf{\textit{\ac{SVR}}}.

\subsection{Problema del sistema de regresión \textit{Lineal} y cómo aliviarlo}

Hemos puesto dos valores con \textit{\textbf{este aspecto}} para indicar que, durante la predicción de la velocidad en el sistema de regresión lineal, hemos modificado una función para obtener unos resultados más apropiados; ya que, de otra forma, se obtendrían valores muy lejanos de la realidad. Nos referimos a la función \textit{filter}:

\begin{center}
\textit{filter(B,1,YHat)}
\end{center}

Esta función filtra los datos de predicción de la matriz \textit{YHat} utilizando una función de transferencia racional definida por los coeficientes del numerador y del denominador \textit{B} y \textit{1} respectivamente, siendo \textit{B} una matriz (\cite{filter}). Los coeficientes de esta matriz los generaremos de la siguiente forma:

\begin{center}
\textit{B = 1/n*ones(n,1)}
\end{center}

Lo que hace la instrucción anterior es crear una matriz de unos (\textit{ones}) de \textit{n} filas y 1 columna, y multiplicar los valores por un factor de \textit{1/n}. Este va a ser el punto en el que vamos a modificar el código para obtener resultados más acordes a lo que se espera, cambiando el valor de \textit{n} para que la función \textit{filter} filtre resultados que excedan por mucho la velocidad real.

Este problema sólo sucede en el sistema de regresión \textit{Lineal}. Puede ser debido a que durante el proceso de \ac{SS} al aplicar niveles más altos de agrupación, se obtiene así más nivel de detalle en las imágenes, y por ende, en los descriptores de imagen; por lo que el sistema se confunde con la información de algunos de estos descriptores cuando están siendo entrenados o predichos, de tal modo que en ciertas partes de la regresión se obtienen picos de resultados que no se corresponden con la realidad. Esto es posible ya que estos picos sólo suceden con niveles de agrupación mayores que 2, por lo que tiene sentido que se deba a algo así.

\begin{figure}[H]
\centering
  \begin{subfigure}[b]{0.5\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Linear_Urban(Nivel_4)(Filter_1000000).eps}
    \caption{Lineal en entornos urbanos para \textbf{Nivel 4} con \textit{filter} a 1000000}
  \end{subfigure}
  \begin{subfigure}[b]{0.5\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Linear_Highway(Nivel_4)(Filter_25000000).eps}
    \caption{Lineal en autovías para \textbf{Nivel 4} con \textit{filter} a 25000000}
  \end{subfigure}
  \caption{Resultados del sistema de regresión lineal modificando la función \textit{filter}}
\end{figure}

Con valores de \textit{n} de 400 en entornos urbanos y de 20 en autovías para el nivel de agrupación 3 y de 10000000 en entornos urbanos y de 25000000 en autovías para el nivel de agrupación 4 se puede llegar a aliviar el problema, pero indudablemente la predicción estará mal en comparación con los niveles anteriores.
%TODO_DONE Te refieres la filtrado? hay que explicarlo, dando detalles y poniendo las gráfica

%Como se puede observar, tanto los sistemas \textit{Boosting Trees} como \textit{\ac{SVR}} son mejores con la nueva versión de $ISA^2$ que integra Swiftnet para entornos urbanos, mientras que para las autovías es mejor utilizar el modelo DeepLab. Esto quiere decir que Swiftnet trabaja mejor con entornos en los que se requiere más nivel de detalle y DeepLab, por el contrario, lo realiza mejor en entornos más abiertos.

\subsection{Resultados finales}

A continuación mostramos algunas figuras con las que podemos ver, de forma gráfica, los resultados de los sistemas de regresión con la \ac{SS} realizada por Swiftnet:

\begin{figure}[H]
  \centering
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Lineal_Highway(Nivel_1).eps}
    \caption{Highway con Lineal usando nivel 1 de agrupación}
  \end{subfigure}
    \begin{subfigure}[b]{0.425\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Lasso_Urban(Nivel_1).eps}
    \caption{Urban con Lasso usando nivel 1 de agrupación}
  \end{subfigure}
    \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Boosting_Urban(Nivel_1).eps}
    \caption{Urban con Boosting usando nivel 1 de agrupación}
  \end{subfigure}
    \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/SVR_Urban(Nivel_1).eps}
    \caption{Urban con SVR usando nivel 1 de agrupación}
  \end{subfigure}
  \caption{Resultados gráficos}
  \label{fig:grafs}
\end{figure}

En la figura \ref{fig:grafs}, los puntos azules representan la velocidad \textbf{real} a la que debe ir el vehículo en cada imagen, mientras que los puntos rojos representan la velocidad \textbf{estimada} por los sistemas de regresión en cada imagen.

Como se puede observar, hemos escogido, en su mayoría, aquellas figuras en las que los sistemas de regresión han dado mejores resultados, es decir, en entornos urbanos \textbf{(Urban)}. Sin embargo, para contrastar cómo trabaja Swiftnet en autovías hemos decidido poner una figura de un sistema con esos datos (\textbf{Highway}), aunque con todos los sistemas se obtiene casi la misma representación gráfica en estos entornos. Nótese cómo hemos escogido los resultados con nivel de agrupación 1 en lugar de otros. Esto es porque, a pesar de que no tienen un gran nivel de detalle, son los que mejores resultados dan en comparación con los demás.

Por último, pasamos a mostrar unas imágenes de ejemplo con la velocidad apropiada, tanto real como estimada, para cada una de ellas usando el sistema \ac{SVR} por ser el claro ganador:

\begin{figure}[H]
\centering
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_MAL_1.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\linewidth}
   % \includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_MAL_2.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_MAL_3.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_MAL_4.eps}
  \end{subfigure}
  \caption{Peores resultados de las imágenes finales en autovías}  
  \label{fig:SVR_Autovia_MAL}
\end{figure}

En la figura \ref{fig:SVR_Autovia_MAL} hemos escogido los 4 peores resultados del sistema \ac{SVR}. Éstos se han realizado con el mismo nivel de agrupación (\textbf{1}), ya que, según la tabla \ref{tab:Resul_ISA2}, son con los que más precisión se consigue.

Como se puede apreciar, en todas ellas se estiman unos valores más apropiados para carreteras convencionales (donde la máxima velocidad permitida es de \textbf{90 km/h}) que para autovías. De hecho, ninguna estimación sobrepasa los \textbf{100 km/h}.

Cabe destacar una imagen excepcional entre todas ellas. Nos referimos a la tercera donde se ve que el vehículo está tomando una salida de la autovía, por lo tanto lo apropiado es aminorar para cumplir con las normas de circulación vigentes, y sin embargo, la predicción excede con creces la velocidad real. Esto puede darse debido a que no hay ninguna etiqueta que represente las marcas viales propias de una carretera, de las que, en este caso, podría valerse para estimar la velocidad de forma eficiente. Puede ser en ese caso que el sistema yerre por creer que sigue en la misma autovía.

A continuación mostramos los mejores resultados en este escenario para el mismo sistema:

\vfill
\begin{figure}[H]
\centering
  \begin{subfigure}[b]{0.475\linewidth}
   % \includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_BIEN_1.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.475\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_BIEN_2.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.475\linewidth}
   % \includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_BIEN_3.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.475\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Autovia_BIEN_4.eps}
  \end{subfigure}
  \caption{Mejores resultados de las imágenes finales en autovías}
  \label{fig:SVR_Autovia_BIEN}
\end{figure}

En la figura \ref{fig:SVR_Autovia_BIEN} escogemos los 4 mejores resultados para el sistema \ac{SVR} usando el mismo nivel de agrupación (\textbf{1}) por ser el que da resultados más aproximados.

Como se puede comprobar, todos los resultados se dan con gran exactitud y sólo existe un cierto error decimal en cada uno. Sin embargo, son un claro ejemplo de que, a pesar de que no es tan bueno, \ac{SVR} estima bien la velocidad en las autovías con Swiftnet; aunque sigue siendo más preciso con DeepLab. No obstante, que un modelo en tiempo real sea capaz de hacer predicciones tan certeras, es una razón de peso para elegirlo.

En la siguiente figura \ref{fig:SVR_Urbano_MAL} pasamos a mostrar los peores resultados en entornos urbanos:

\begin{figure}[H]
\centering
  \begin{subfigure}[b]{0.475\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_MAL_1.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.475\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_MAL_2.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.475\linewidth}
   % \includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_MAL_3.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.475\linewidth}
   % \includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_MAL_4.eps}
  \end{subfigure}
  \caption{Peores resultados de las imágenes finales en entornos urbanos}
  \label{fig:SVR_Urbano_MAL}
\end{figure}

Para estas imágenes (\ref{fig:SVR_Urbano_MAL}) seguimos utilizando el nivel de agrupación \textbf{1} para el mismo sistema de regresión (\ac{SVR}), por ser el que tiene el \ac{MAE} más bajo de todos ellos (\ref{tab:Resul_ISA2}).

Podemos ver cómo en todas ellas la predicción queda muy lejos de la realidad aproximando unos valores más propios de un área como el centro de una ciudad, mientras que estas imágenes, a pesar de considerarse como entornos urbanos, permiten una mayor flexibilidad para conducir a velocidades superiores (del orden de \textbf{40} o \textbf{50 km/h}).

Al igual que en la figura \ref{fig:SVR_Autovia_MAL}, tenemos una imagen excepcional cuya estimación puede deberse a lo siguiente: En la primera imagen vemos cómo Swiftnet detecta que hay una persona cerca, lo cual puede conllevar a que la estimación se haga para una situación que no existe (por ejemplo, el sistema podría pensar que la persona está a una distancia peligrosa y por lo tanto reducir considerablemente la velocidad para evitar un posible accidente).

Finalmente mostramos los mejores resultados de \ac{SVR} con el mismo nivel de agrupación en entornos urbanos:

\begin{figure}[H]
\centering
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_BIEN_1.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\linewidth}
   % \includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_BIEN_2.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_BIEN_3.eps}
  \end{subfigure}
  \begin{subfigure}[b]{0.45\linewidth}
    %\includegraphics[width=\linewidth]{Figuras/Resultado_SVR_Urbano_BIEN_4.eps}
  \end{subfigure}
  \caption{Mejores resultados de las imágenes finales en entornos urbanos}
  \label{fig:SVR_Urbano_BIEN}
\end{figure}

En la figura \ref{fig:SVR_Urbano_BIEN}, podemos comprobar que todas las predicciones aciertan casi en su totalidad con la velocidad real de estas escenas. La primera es un claro ejemplo de ello cuando vemos que tiene un error de tan sólo \textbf{0.06 km/h}.
%TODO: faltan muchas cosas.
%TODO_DONE: 1) Hay que aclarar que los anteriores resultados, para cada regresor, han sido obtenidos con unos parámetros para el spatial pyramids concretos. Debemos ponerlos.
%TODO_DONE: 2) Hay que enriquecer este capítulo con un análisis de la influencia del nivel de la pirámide para cada regresor, así se entenderá porqué hemos puesto los ganadores en la primera tabla. Básicamente una tabla donde comparemos todos con todos los niveles del 1 al 4.
%TODO_DONE: 3)falta una sección con los resultados de evaluación en cityscapes en términos de segmentación semántica, donde podamos ver que replicamos los resultados del paper original. Yo pondría esta subsección la primera.

%4)TODO_DONE: Resultados cualitativos: añadir imágenes donde se vea la predicción de la velocidad, y la velocidad anotada, hay que seleccionar las mejores y las peores, y comentarlo. Puedes hacerlo para el modelo ganador nuestro, y creas dos figuras, una con imágenes urbanas y otra con imágenes de autopista. Puedes poner las 4 mejores y las 4 peores. 


%5) Para el examen conviene que tengas una demo lista en la que podamos ver el sistema funcionando. Lo lanzas contra una carpeta de imágenes y va una a una generando la velocidad, que se guarda en una imagen donde se vea el dato superpuesto, como si fuera un video. Si tienes dudas comentamos. Eso te va a permitir generar un gif a modo de video que te va a quedar muy chulo. 


%TODO_DONE: 6) Hecho en falta un análsis tiempos de procesado del switnet, para terminar de vender lo de que es tiempo real, vaya. Debes añadirlo.
